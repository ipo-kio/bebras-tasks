<head><title>Relax</title>
    <script type="text/javascript" src="raphael-min.js"></script>
</head>
<body>

<div style="font-size:48px">
    <b>Relax</b>
</div>
<div style="font-size:24px">
    <p>
        In a quaint little beaver town, the population is very relaxed about time. The beavers divide the day into 8
        intervals of 3 hours and only want to know the current interval. To tell the time they look at the town hall, a
        building with three steeples. A flag is flying on top of each, either a blue triangle or a red square. Each
        pattern signals a time interval as shown below.
        The mayor is proud of the system because only one flag changes from each interval to the next, except at
        midnight when all three flags need to be changed.
    </p>
    <p>
        <b>Challenge:</b> Find an even more relaxing pattern that never requires changing more than one flag at a time:
        Drag any pattern to the outside and then drop another pattern onto an empty slot. <i>(The little circles between
        the slots are blue if only one flag needs to be changed between the two neighboring slots; otherwise they are
        red.)</i>
    </p>
</div>

<!--pos: <input type=text id=pos>
on: <input type=text id=on>
correct? <input type=text id=richtig>-->
<div id=container style="touch-action: none"></div>
<script>
    function touchHandler(event) {
        var touches = event.changedTouches,
            first = touches[0],
            type = "";
        switch (event.type) {
            case "touchstart":
                type = "mousedown";
                break;
            case "touchmove":
                type = "mousemove";
                break;
            case "touchend":
                type = "mouseup";
                break;
            default:
                return;
        }

        // initMouseEvent(type, canBubble, cancelable, view, clickCount,
        //                screenX, screenY, clientX, clientY, ctrlKey,
        //                altKey, shiftKey, metaKey, button, relatedTarget);

        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(type, true, true, window, 1,
            first.screenX, first.screenY,
            first.clientX, first.clientY, false,
            false, false, false, 0/*left*/, null);

        first.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    }

    function init() {
        document.addEventListener("touchstart", touchHandler, true);
        document.addEventListener("touchmove", touchHandler, true);
        document.addEventListener("touchend", touchHandler, true);
        document.addEventListener("touchcancel", touchHandler, true);
    }

    init();
    C = .7;
    counter = 0;
    xoff = C * 640; // offset to clock center
    yoff = C * 640; // offset to clock center
    r = C * 310; // radius of center to 8 positions
    picw = C * 170; // width of each of the 8 pics
    pich = C * 170; // height of each of the 8 pics
    circ = new Array(8);
    correct = false;
    clockw = C * 850;
    clockh = C * 850;
    rr = clockw / 2; // radius of center to circle, approx.
    maxd = xoff - picw / 2; // max x or y distance allowed from center
    R = new Raphael(document.getElementById('container'),
        xoff + maxd + picw / 2, yoff + maxd + pich / 2);
    flag = [ // 0=blue, 1=red
        [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],
        [0, 1, 1], [0, 0, 1], [1, 0, 1], [1, 1, 1]
    ];
    pos = [0, 1, 2, 3, 4, 5, 6, 7]; // on timezone x is pos[x]
    function check() {
        score = 0;
        for (i = 0; i < 8; i++) {
            if (pos[i] == null || pos[(i + 1) % 8] == null)
                circ[i].attr({fill: '#fff'});
            else {
                sum = 0;
                for (j = 0; j < 3; j++)
                    if (flag[pos[i]][j] != flag[pos[(i + 1) % 8]][j])
                        sum++;
                circ[i].attr({fill: (sum == 1 ? '#00f' : '#f00')});
                if (sum == 1) score++;
            }
        }
        correct = false;
        if (score == 8) correct = true;
    }

    function getTimeZone(px, py) { // which 3-hour-interval?
        if (px > 0) {
            if (py < 0) return -py > px ? 0 : 1;
            else return px > py ? 2 : 3;
        } else {
            if (py > 0) return py > -px ? 4 : 5;
            else return -px > -py ? 6 : 7;
        }
    }

    R.rect(xoff - maxd, yoff - maxd, maxd * 2, maxd * 2)
        .attr({stroke: 'none', fill: '#fff'});
    Raphael.st.draggable = function () {
        var me = this,
            lx = 0,
            ly = 0,
            ox = 0,
            oy = 0;
        moveFnc = function (dx, dy) {
            me.on = null;
            if (me.getBBox().x < picw) dx += 1;
            if (me.getBBox().y < pich) dy += 1;
            if (me.getBBox().x > clockw + picw) dx -= 1;
            if (me.getBBox().y > clockh + pich) dy -= 1;
            lx = dx + ox;
            ly = dy + oy;
            me.transform('t' + lx + ',' + ly);
        },
            startFnc = function () {
                me.toFront();
                if (me.on != null) {
                    me.oldon = me.on;
                    pos[me.on] = null;
                    me.on = null;
                } else me.oldon = null;
            },
            endFnc = function () {
                // position of clock center relative to castle
                px = lx + me.x + picw / 2;
                py = ly + me.y + pich / 2;
                if (px * px + py * py < rr * rr * 1.4) {
                    timezone = getTimeZone(px, py);
                    dropovercastle = R.getById(3 + 2 * pos[timezone]);
                    if (pos[timezone] == null && rr * rr * .4 < px * px + py * py) {
                        pos[timezone] = me.idx;
                        me.on = timezone;
                        lx = r * Math.cos(Math.PI * ((2 * timezone - 3) / 8)) - picw / 2 - me.x;
                        ly = r * Math.sin(Math.PI * ((2 * timezone - 3) / 8)) - pich / 2 - me.y;
                    } else {
                        me.on = me.oldon;
                        if (me.on != null) pos[me.on] = me.idx;
                        lx = ox;
                        ly = oy;
                    }
                } else {
                    me.on = null;
                    out = false;
                    if (px < -maxd) {
                        px = -maxd;
                        out = true;
                    }
                    if (py < -maxd) {
                        py = -maxd;
                        out = true;
                    }
                    if (px > maxd) {
                        px = maxd;
                        out = true;
                    }
                    if (py > maxd) {
                        py = maxd;
                        out = true;
                    }
                    if (out) {
                        lx = px - picw / 2 - me.x;
                        ly = py - pich / 2 - me.y;
                    }
                }
                //document.getElementById('pos').value=pos;
                on = new Array(8);
                for (i = 0; i < 8; i++) on[i] = imgSet[i].on;
                //document.getElementById('on').value=on;
                ox = lx;
                oy = ly;
                check();
                me.transform('t' + ox + ',' + oy);
            };
        this.drag(moveFnc, startFnc, endFnc);
    };
    R.image('clock.svg', yoff - clockw / 2, xoff - clockh / 2, clockw, clockh);
    imgSet = new Array(8);
    for (i = 0; i < 8; i++) {
        circ[i] = R.circle(
            xoff + rr * Math.cos((i - 1) / 4 * Math.PI),
            yoff + rr * Math.sin((i - 1) / 4 * Math.PI), 12 * C).attr({fill: '#fff'});
        circ[i].attr({fill: '#f00'});
        imgSet[i] = R.set();
        // vectors from clock center to each castle image:
        dx = r * Math.cos(Math.PI * ((2 * i - 3) / 8)) - picw / 2,
            dy = r * Math.sin(Math.PI * ((2 * i - 3) / 8)) - pich / 2,
            imgSet[i].push(R.image('flags' + i + '.svg',
                xoff + dx, yoff + dy, picw, pich));
        imgSet[i].idx = i; // ID does not change
        imgSet[i].on = i; // currently on same time zone as ID
        imgSet[i].oldon = i;
        imgSet[i].x = dx;
        imgSet[i].y = dy;
        imgSet[i].draggable();
    }
    sc = 2.2;
    scx = 114;
    scy = 181;
    hand = R.image('hand.svg',
        xoff - (sc * scx / 4) * C, yoff - (sc * scy / 4) * C,
        sc * scx / 2 * C, sc * scy / 2 * C);

    function petik() {
        X = new Date();
        time = X.getHours() * 3600 + X.getMinutes() * 60 + X.getSeconds() - 36000;
        hand.transform('r' + (time / 240) + 't-' + (3.75 * C) + ',0');
        window.setTimeout(petik, 60000);
    }

    petik();
    sc = 30;
    center = R.image('center.svg', xoff - sc / 2 * C, yoff - sc / 2 * C, sc * C, sc * C);
    check();
</script>
</body>
<!--Fabian Frei and Peter Rossmanith jr.-->
