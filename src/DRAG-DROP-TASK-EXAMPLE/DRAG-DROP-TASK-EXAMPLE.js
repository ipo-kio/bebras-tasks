export class Task {

    /*
    Будем делать задачу про то, чтобы расставить цвета по порядку, как в радуге.
    В файле DRAG-DROP-TASK-EXAMPLE.png находится картинка с четырьмя цветами. В задачах
    нужно иметь одну картинку, содержащую все необходимые для задачи изображения. Имя картинки
    совпадает с именем задачи.
    В процессе отладки, чтобы отладка работала, необходимо иметь две версии картинки, одна называется
    TASK.png, другая TASK.nocompress.png, сейчас они одинаковые, но перед публикацией задачи с помощью
    сервиса https://tinify.com/ картинка TASK.png уменьшается в размере практически без потери качества.

    Создать одну общую картинку из других можно вручную, а можно с помощью Java программы в каталоге ImagesUnion,
    про это будет отдельный тюториал при необходимости.

    Задача создаётся с помощью библиотеки ddlib, которую сделали специально для конкурса Бобёр еще в 12 году,
    а сама ddlib основана на библиотеке kinetic. Ранее она была популярна, сейчас не поддерживается, но
    кажется до сих пор надёжно работающей.

    Класс с задачей создаёт система и вызывает нужные методы по мере необходимости. Т.е. используется
    обращение зависимости.
     */

    /**
     * Инициализация задачи
     * @param container id элемента внутри html, это div, внутри которого надо создавать интерфейс задачи
     * @param pictures объект вида {'bg': "https://......../x.png"}, он содержит картинки для задачи.
     * Обычно есть только одна картинка `bg` со всеми нужными для задачи изображениями, склеенными вместе
     */
    constructor(container, pictures) {
        // задаём размер поля с задачей
        let WIDTH = 600;
        let HEIGHT = 300;

        // задаём объекты на экране
        let places = [
            // сначала несколько объектов с цветами для перемещения
            new Place(
                50, 50, 100, 100, // создаём объект на экране, в точке 50, 50 ширина и высота 100 и 100
                'blue', // идентификатор объекта, необязательно уникальный
                2, // 2 - перемещаемый объект, 0 - место, куда можно перенести объект, 1 - статический объект.
                { // описание объекта
                    imageId: 'bg', // ссылка на картинку. bg означает ту самую картинку, которая называется как задача
                                   // иметь какие-то другие картинки с другими идентификаторами почти никогда не нужно
                    crop: { // координаты для вырезания из картинки
                        x: 0, y: 0, // координаты на картинке bg
                        width: 100, height: 100 // высота и ширина
                    }
                }
            ),
            new Place(170, 50, 100, 100, 'green', 2, {imageId: 'bg', crop: {x: 100, y: 0, width: 100, height: 100}}),
            new Place(290, 50, 100, 100, 'yellow', 2, {imageId: 'bg', crop: {x: 0, y: 100, width: 100, height: 100}}),
            new Place(410, 50, 100, 100, 'red', 2, {imageId: 'bg', crop: {x: 100, y: 100, width: 100, height: 100}}),

            // теперь несколько объектов, куда можно перемещать цвета
            new Place(
                50, 170, 100, 100, // положение и размер объекта
                'place1', // идентификатор
                0, // 0 - место, куда можно перенести объект
                { // описание места
                    stroke: "green", // цвет бордюра
                    strokeWidth: 2,  // толщина бордюра
                    dashArray: [4, 4]  // настройка пунктира - 4 пикселя линия, 4 пикселя пропуск
                    // можно поискать другие возможности оформления, это описание объекта из библиотеки kintetic
                }
            ),
            new Place(170, 170, 100, 100, 'place2', 0, {stroke: "green", strokeWidth: 2,  dashArray: [4, 4]}),
            new Place(290, 170, 100, 100, 'place3', 0, {stroke: "green", strokeWidth: 2,  dashArray: [4, 4]}),
            new Place(410, 170, 100, 100, 'place4', 0, {stroke: "green", strokeWidth: 2,  dashArray: [4, 4]})
        ];

        // наконец, инициализация задачи. Создание интерфейса внутри div (id=container) происходит с помощью
        // библиотеки ddlib.
        // Без библиотеки необходимо с помощью JS создать полностью весь DOM внутри div
        this.ddlib = new App(container, WIDTH, HEIGHT, pictures, places, true);
    }

    /**
     * Эта функция должна сбрасывать задачу в начальное положение, как будто ее еще не решали.
     * Здесь мы делегируем это действие в ddlib.
     */
    reset() {
        this.ddlib.reset();
    };

    /**
     * Задача включается и выключается, выключение нужно, чтобы после того, как участник послал решение,
     * он понимал, что больше не может взаимодействовать с задачей. Обычно задача засеряется, и элементы
     * управления перестают работать. Если участник хочет исправить решение, он нажмет кнопку "Изменить ответ",
     * задача снова станет активной, а на сервер пошлется сообщение, что участник отменил свой ответ.
     *
     * Здесь поведение делегируется ddlib
     * @returns {boolean}
     */
    isEnabled() {
        return this.ddlib.isEnabled();
    };

    /**
     * Этот метод система будет вызывать, чтобы включитьи ли выключить задачу. {@see isEnabled}.
     *
     * Поведение делегируется ddlib
     * @param state
     */
    setEnabled(state) {
        this.ddlib.setEnabled(state);
    };

    /**
     * Некоторые задачи могут инициализироваться не сразу после вызова конструктора. Обычно, например,
     * нужно время на загрузку изображений. Система хочет поставить слушатель на тот момент, когда
     * задача инициализируется полностью.
     * Функция _initCallback не имеет аргументов, ее надо вызывать после завершение инициализации
     *
     * Здесь поведение делегируется в ddlib
     * @param _initCallback
     */
    setInitCallback(_initCallback) {
        this.ddlib.setInitCallback(_initCallback);
    };

    /**
     * Система будет вызывать этот метод, чтобы получить символьное представление текущего решения задачи.
     * Именно эта строка будет отсылаться на сервер в качестве ответа участника.
     * По этой строке необходимо уметь восстанавливать решение участника, см. {@see loadSolution}
     *
     * Рекомендуется возвращать пустую строку, если текущее решение совпадает с начальным. Т.е. после вызова функции
     * `reset()` функция `getSolution()` должна желательно вернуть пустую строку.
     * @returns {string}
     */
    getSolution() {
        return this.ddlib.getSolution();
    }

    /**
     * Эта функция должна загрузить решение, получив строку с решением. Строка с решением была раньше получена
     * из метода `getSolution()`, но полагаться на это нельзя, из-за сбоев в сети или из-за нечестных участников
     * строка может быть модифицирована. Поэтому нужно быть готовым, что строка некорректна, в этом случае загружать
     * решение не нужно.
     * @param solution
     * @returns {boolean} Возвращается, успешно ли загружено решение.
     */
    loadSolution(solution) {
        return this.ddlib.loadSolution(solution);
    }

    /**
     * Возвращается, верное ли у участника решение. Проверять решение можно прямо в коде, внутри этого метода
     * т.е. на компьютере участника. Тогда надо возвращать -1 (нет ответа), 0 (неправильный ответ), 1
     * (правильный ответ).
     *
     * Если решение проверяется на сервере, нужно возвращать 2. Тогда сервер получит строку из метода
     * `getSolution()` и сравнит ее с правильной или одной из правильных.
     * @returns {number}
     */
    getAnswer() { //-1 no answer, 0 wrong, 1 correct, 2 - server check
        //Для проверки можно (но необязательно, здесь мы это не делаем)
        //вызвать this.ddlib.getOutput(), эта функция возвращает объект, который указывает,
        //на каком поле находится какой элемент. Например, `{place1: green, place2: yellow}` и т.п.

        return 2;
    }
}

/**
 * {"4":3,"5":2,"6":1,"7":0}
 *
 * В конце в комментарии к задаче нужно оставить правильное решение. Это результат работы метода `getSolution()`
 * в момент, когда решение в задаче верное. Чтобы увидеть его, решите задачу правильно, откройте JS консоль
 * разработчика и нажмите "Сохранить решение".
 */